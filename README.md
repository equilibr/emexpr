# EmExpr

*The following text is written in the present tense, even during development, to keep a reminder of the project goals.*

EmExpr is a small, zero-dependency, zero-allocation expression parser and evaluation engine for mathematical expressions. It is aimed to be used in embedded systems where resources are at a premium and must be tightly controlled.

It has no `#include` directives (other than its own header), not even `memory` nor `math`. This allows it to be used even in bare metal project where there is very limited runtime support and when precise control over memory and processor usage is needed. It can be used in places where there is no `malloc` available, for example, or when the mathematical library is not even implemented.

It is highly configurable, allowing to use any C built-in basic type as storage and performing any operations on it. This can be a float point, integer or even a complex fixed-point arithmetic, for example, with no changes in the expression syntax.

The parsing and execution steps are separated allowing for the lowest possible resource usage and fastest possible reevaluation of parsed expressions. Variables, constants and functions are bound (not copied) during parsing so each evaluation uses the current data from memory.

There is no shared mutable state in the code. Thus, if needed, it can be executed concurrently, given the referenced data and functions also support this.

## Design philosophy

### Expression parser

The parser is implemented as a table-driven, non-recursive, Pratt parser, with support for prefix, infix & postfix operators and controllable precedence.

Being a table-driven parser the parsed language grammar can be easily modified, if needed, without the need to even understand how the code works. For example, changing the precedence of operators is a simple operation of changing the corresponding integers in the table. This also allows for storing the language tables in ROM memory, or another memory bank, if needed, to conserve RAM or speed-up execution using simultaneous memory bank access.

The non-recursive nature of the parser help to keep the call stack depth to a known minimum while parsing expressions of any complexity, as many embedded systems have extreme limitations on the depth and size of the call stack. For less-constrained systems this can also provide protection from call stack overflow when parsing large and/or maliciously constructed user-provided expressions.

### Evaluation environment

The parser generates a semi-opaque structure, the evaluation environment, that is used for evaluating the expression. This allows to, both, discard the expression after parsing to conserve memory and to execute the evaluation multiple times conserving processor usage.

There is a helper estimator function that provides the upper bound on the memory needed for the environment, for a given expression, using a simple algorithm. This is to allow pre-allocating storage for it since the parser does not perform any allocations by itself. The parser will report the actual memory used so it can be trimmed, if needed.

It is also possible to run the parser itself in a special calculation mode. This mode uses the bare minimum of memory and returns a much better estimate for the actual needed memory. Thus a trade-off between processor usage and memory usage during parsing is possible.

This environment structure holds the generated byte code, parsed constants, pointers to user-bound variables and functions and some housekeeping information.  The structure is self contained, never written to by the evaluation engine, can be freely moved in memory, stored on the stack, heap, or any other accessible memory location.

Since the evaluation engine needs a runtime stack of its own to execute the environment storage for this stack can also be allocated inside the environment - to simplify executing the evaluation step.
On the other hand it is possible to keep the environment size to a minimum and provide user allocated memory for the runtime stack. This memory can be located anywhere in RAM, e.g. heap, pre-allocated static memory or on the C runtime stack itself.

### Evaluation engine

The evaluation engine is implemented as a byte-code driven, stack based, virtual machine. This allows for a simple, small, implementation, high execution speed and low memory usage. The implementation uses the shallowest possible call stack and no memory other than provided by the evaluation environment.

All data processing - operators, function calls, custom constant and special variables access - is performed with user provided functions. No functionality other than the four basic operations `+-*/`, also implemented as user functions, is provided by default and even those can be excluded from compilation. This completely decouples the evaluation engine from the data processing keeping it, at the same time, as simple and as flexible as possible.

The engine handles only a single, user defined, type of value. All variables, constants, function parameters and return data, as well as the execution stack itself are of this type. The engine does not care about the actual type, only that it can be copied using the `=` (C assignment) operator, stored in memory and a pointer to it can be taken and de-referenced.  User functions are the only ones that should actually care what this type is since they are the ones who perform operations on it.

## Usage

To obtain the result of evaluating an expression two steps must be performed: parsing and evaluating.

The first step, parsing, analyzes the expression and any additionally user provided data and prepares an evaluation environment. This environment is then used in the second step, evaluation, to actually generate the result.

### Size estimation

Since there is no way to know in advance, before parsing, how much space will be needed for the evaluation environment, an estimator function can be called. This function is given the actual expression and it fills the environment header with size estimation data.
This would look like this:

```C
    ee_environment_header header;
    if (ee_guestimate("40+2",&header))
        return;//There was some error
```

At this point an adequately sized buffer can be allocated.
It is entirely possible to just allocate some space and reject all expressions that require more that.

### Parsing

No matter the strategy, the next step is performing the actual parsing.
For the example we assume the buffer is pre-allocated to some constant value.

```C
  enum {EnvironmentSize = 64};
  union
  {
     ee_environment_header  header;
     ee_environment_element data[EnvironmentSize];
  }  environment;
  environment.header.size = EnvironmentSize;
  
  ee_compilation_data data;
  const char * expression = "40+2";
  
  int result = ee_compile(expression , &environment.header,  &data);
  if (result)
    //This can be used to display a specific error message
    return result;
```
One very important piece of code is left unexplained, the `ee_compilation_data`. It is extensively discussed as part of the [user interface](#UserInterface).

### Evaluation

If the parsing completed without errors the expression can be evaluated. 
Note that, at this point, the only piece of data that we need to keep is the evaluation environment, `environment`. All the other data used before, as well as the expression itself, are no longer needed.

```C
  //We assume the result of the evaluation is of some interest.
  ee_variable_type result;
  
  int evaluated = ee_evaluate(&environment.header, &result);
  if (evaluated)
    //This can be provided by a user function during evaluation
    return evaluated;
```

This step can be execute as many times as needed, interleaved with other execution.

For example, assume there are two expressions, that were parsed beforehand, that are only needed for the side-effects of the user functions they execute. Code like the following could be used to execute them, repeatedly, until one of the user functions returns some non-zero value.

```C
  static const char * expr1 = "foo()";
  static const char * expr1 = "bar()";

  //Parsing was done here into env1 & env2
  
  ee_variable_type dummy;
  while (!ee_evaluate(&env1, &dummy) && ee_evaluate(&env2, &dummy)) ;
```

## <a name="UserInterface"></a> User interface

## Syntax
This describes the default syntax. The syntax can be modified at any scale, from changing the precedence of a single operator to using completely different grammar.

## Support code
To simplify the general use case support code is provided, as additional sources, with bindings to functions from`math.h` and `cmath.h`, for several variable types.

To allow for more informative feedback to the user who parses expressions conversion functions, from the parser error codes to user readable strings, is provided. This can be used in systems where textual user feedback is possible to help with writing correct expressions. This is also provided as an additional source file that can be used only by those who need such a facility.

For users who want to *just use* the library a function is provided that takes an expression as input and returns the result as output. This function has a simplified API for variable binding and it includes the default math functions in the evaluation.

```C
    double myVar = 0;
    double result = eelib_execute("cos(2 * PI * phi", "phi", &myVar);
```


## Future

This is a list of things to consider after the project is in a working state.

### Logic

Add comparison operations and boolean operators.
This should be implemented with the used variable type and without any modification to the execution engine.
This can, basically, be done by simply adding new operators to the parser table and providing the relevant support functions.
The requirement to not modify the engine means there will be no short-circuiting support since that would need the ability to control the execution flow.

### Variables

Allow using user defined variable types. Currently only the behavior can be changed but the variable must be a C built-in.

### Environment sharing

Allow sharing of the evaluation environment for different expressions.
This can be done by allowing the parser to append data to an existing environment. It can be used to conserve memory when many expression share the same set of constants, variables and functions.

### Direct data

Remove usage of constant/variable/function tables and provided the data directly in the byte code stream.

This can make the environment sharing redundant and simplify the implementation of the evaluation engine even further. On the other hand this can make execution slower and actually use more memory, especially when the same identifiers are used multiple times in an expression or across different expressions thus negating any possible gains. 

### Optimizations

Any optimization performed should only be done in the parser and must not add any complexity to the execution engine.
It must be possible for the user to disable this. Not only to keep the parser resource usage to a minimum but also because of system limitations, such as the inability to execute user provided functions during parsing.

This can include things such as common sub-expression elimination and constant folding.
This can also try and automatically estimate if the direct data approach, as outlined above, should be used on a per-case basis.

### Source separation
Separate the parser and execution engine to different source files to simplify applying different optimization techniques to each, e.g. `-Os` for the parser and `-O3` for the execution engine.

### Beyond expressions

The project should stay **expression** based.
This mostly means not adding execution flow control.

It will be simple to add writing to variables and parsing several expressions in a single evaluation environment, allowing syntax such as `a = ...expression...; b = ...expression...;`. This will not require any change in the API and thus can be added at a later time without interfering with existing users.

It should be noted that this can, currently, be emulated by using user functions to perform the writes, as in `writeA(...expression...) + writeB(...expression...)`.

Even if only a single expression is allowed writing to variables with a simple syntax can be beneficial for use cases such as dynamically provided user defined variable drivers, simple configuration scripts where each line is treated as an expression, etc...