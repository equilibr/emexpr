
# EmExpr

*The following text is written in the present tense, even during development, to keep a reminder of the project goals.*

EmExpr is a small, zero-dependency, zero-allocation expression parser and evaluation engine for mathematical expressions. It is aimed to be used in embedded systems where resources are at a premium and must be tightly controlled.

It has no `#include` directives (other than its own header), not even `memory` nor `math`. This allows it to be used even in bare metal project where there is very limited runtime support and when precise control over memory and processor usage is needed. It can be used in places where there is no `malloc` available, for example, or when the mathematical library is not even implemented.

It is highly configurable, allowing to use any C built-in basic type as storage and performing any operations on it. This can be a float point, integer or even a complex fixed-point arithmetic, for example, with no changes in the expression syntax.

The parsing and execution steps are separated allowing for the lowest possible resource usage and fastest possible reevaluation of parsed expressions. Variables, constants and functions are bound (not copied) during parsing so each evaluation uses the current data from memory.

There is no shared mutable state in the code. Thus, if needed, it can be executed concurrently, given the referenced data and functions also support this.

## Design philosophy

### Expression parser

The parser is implemented as a table-driven, non-recursive, Pratt parser, with support for prefix, infix & postfix operators and controllable precedence.

Being a table-driven parser the parsed language grammar can be easily modified, if needed, without the need to even understand how the code works. For example, changing the precedence of operators is a simple operation of changing the corresponding integers in the table. This also allows for storing the language tables in ROM memory, or another memory bank, if needed, to conserve RAM or speed-up execution using simultaneous memory bank access.

The non-recursive nature of the parser help to keep the call stack depth to a known minimum while parsing expressions of any complexity, as many embedded systems have extreme limitations on the depth and size of the call stack. For less-constrained systems this can also provide protection from call stack overflow when parsing large and/or maliciously constructed user-provided expressions.

### Evaluation environment

The parser generates a semi-opaque structure, the evaluation environment, that is used for evaluating the expression. This allows to, both, discard the expression after parsing to conserve memory and to execute the evaluation multiple times conserving processor usage.

There is a helper estimator function that provides the upper bound on the memory needed for the environment, for a given expression, using a simple algorithm. This is to allow pre-allocating storage for it since the parser does not perform any allocations by itself. The parser will report the actual memory used so it can be trimmed, if needed.

It is also possible to run the parser itself in a special calculation mode. This mode uses the bare minimum of memory and returns a much better estimate for the actual needed memory. Thus a trade-off between processor usage and memory usage during parsing is possible.

This environment structure holds the generated byte code, parsed constants, pointers to user-bound variables and functions and some housekeeping information.  The structure is self contained, never written to by the evaluation engine, can be freely moved in memory, stored on the stack, heap, or any other accessible memory location.

Since the evaluation engine needs a runtime stack of its own to execute the environment storage for this stack can also be allocated inside the environment - to simplify executing the evaluation step.
On the other hand it is possible to keep the environment size to a minimum and provide user allocated memory for the runtime stack. This memory can be located anywhere in RAM, e.g. heap, pre-allocated static memory or on the C runtime stack itself.

### Evaluation engine

The evaluation engine is implemented as a byte-code driven, stack based, virtual machine. This allows for a simple, small, implementation, high execution speed and low memory usage. The implementation uses the shallowest possible call stack and no memory other than provided by the evaluation environment.

All data processing - operators, function calls, custom constant and special variables access - is performed with user provided functions. No functionality other than the four basic operations `+-*/`, also implemented as user functions, is provided by default and even those can be excluded from compilation. This completely decouples the evaluation engine from the data processing keeping it, at the same time, as simple and as flexible as possible.

### Support code
To simplify the general use case support code is provided, as additional sources, with bindings to functions from`math.h` and `cmath.h`, for several variable types.

To allow for more informative feedback to the user who parses expressions conversion functions, from the parser error codes to user readable strings, is provided. This can be used in systems where textual user feedback is possible to help with writing correct expressions. This is also provided as an additional source file that can be used only by those who need such a facility.

## Future

This is a list of things to consider after the project is in a working state.

### Logic

Add comparison operations and boolean operators.
This should be implemented with the used variable type and without any modification to the execution engine.
This can, basically, be done by simply adding new operators to the parser table and providing the relevant support functions.
The requirement to not modify the engine means there will be no short-circuiting support since that would need the ability to control the execution flow.

### Variables

Allow using user defined variable types. Currently only the behavior can be changed but the variable must be a C built-in.

### Environment sharing

Allow sharing of the evaluation environment for different expressions.
This can be done by allowing the parser to append data to an existing environment. It can be used to conserve memory when many expression share the same set of constants, variables and functions.

### Direct data

Remove usage of constant/variable/function tables and provided the data directly in the byte code stream.

This can make the environment sharing redundant and simplify the implementation of the evaluation engine even further. On the other hand this can make execution slower and actually use more memory, especially when the same identifiers are used multiple times in an expression or across different expressions thus negating any possible gains. 

### Optimizations

Any optimization performed should only be done in the parser and must not add any complexity to the execution engine.
It must be possible for the user to disable this. Not only to keep the parser resource usage to a minimum but also because of system limitations, such as the inability to execute user provided functions during parsing.

This can include things such as common sub-expression elimination and constant folding.
This can also try and automatically estimate if the direct data approach, as outlined above, should be used on a per-case basis.

### Source separation
Separate the parser and execution engine to different source files to simplify applying different optimization techniques to each, e.g. `-Os` for the parser and `-O3` for the execution engine.

### Beyond expressions

The project should stay **expression** based.
This mostly means not adding execution flow control.

It will be simple to add writing to variables and parsing several expressions in a single evaluation environment, allowing syntax such as `a = ...expression...; b = ...expression...;`. This will not require any change in the API and thus can be added at a later time without interfering with existing users.

It should be noted that this can, currently, be emulated by using user functions to perform the writes, as in `writeA(...expression...) + writeB(...expression...)`.

Even if only a single expression is allowed writing to variables with a simple syntax can be beneficial for use cases such as dynamically provided user defined variable drivers, simple configuration scripts where each line is treated as an expression, etc...